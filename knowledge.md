# Выражения и Операторы

Одно важное различие между Адой итаким языком, как C, заключается в том, что  ператоры  и выражения очень четко различаются. В Ада, если вы попытаетесь использовать  выражение, там, где требуется оператор, ваша программа не будет скомпилированна.  Это правило реализует полезный стилистический принцип: преднозначение выражений  в вычислении значений, а не для в побочных эффектах. Оно также может предотвратить  некоторые ошибки программирования, такие как ошибочное использование операции  проверки на равенства = вместо операции присваивания := в операторе присваивания.

```ada
procedure Foo is 
   X: Integer := 0;
   Y: Integer := 1;
   
begin

   X := Y := 1; -- CE

   if X := 1 then -- CE
   end if;

end Foo;  
```

# Зоны Описания

Как упоминалось ранее, Ада проводит четкое синтаксическое разделение между  объявлениями, которые вводят имена для сущностей, которые будут использоваться в  программе, и операторами, выполняющими обработку. Области в программе, в которых  могут появляться объявления, называются зонами описания.  Влюбойподпрограммеучасток кода между is и begin является зоной описания. Там могут быть переменные, константы, типы, внутренние подпрограммы и другие сущности.

# Подпрограммы

Функции или Процедуры

# Записи (Record)

```ada
 type Date is record-- The following declarations are-- components of the record
   Day : Integer range 1 .. 31;
   Month : Months; -- You can add custom constraints-- on fields
   Year : Integer range 1 .. 3000;
 end record;
```

Для записи

### Извлечение компоненты

`D.Month`

### Агрегаты

Агрегат - это список значений, разделенных запятыми и заключенных в круглыес кобки. Он  разрешен в любом контексте, где ожидается значение записи.

Инициализация: `Ada_Birthday :Date:=(10,December, 1815);`

## Cовмещение

Перегрузка по возвращаемому значению.

# Ссылки

```ada
type Date_Acc is access Date; -- reference
D : Date_Acc := null;
D := new Integer; -- allocation
D.all = 1; -- dereferencing
```

# Инкапсуляция

```ada
package Encapsulate is
  -- видимый раздел
  procedure Hello;
  private
  procedure Hello2;-- Not visible from external units
end Encapsulate;
```

```ada
with Encapsulate;
 
procedure Main is
begin
   Encapsulate.Hello;
   Encapsulate.Hello2;  -- Invalid: Hello2isnotvisible
end Main;
```

# Производные типы

```ada
package Newtypes is
   type Point is record
     X, Y : Integer;
   end record;
   
  type New_Point is new Point;
 end Newtypes;
```

Когда вы наследуете тип, вы также наследуете так называемые примитивные операции.  Примитивнаяоперация(илипростопримитив)-этоподпрограмма,привязаннаяктипу. Ада  определяет примитивы как подпрограммы, определенные в той же области, что и тип

Attention: Обратите внимание: подпрограмма станет примитивом этого типа только в  том случае, если:

1. Подпрограмма объявляется в той же области, что и тип
2. Тип иподпрограмма объявляются в пакете

# Теговые типы

Теговые типы очень похожи на обычные записи, за исключением того, что добавлена следующая функциональность:

* **Наличие тега.** Каждый объект тегового типа содержит специальное поле — **тег**, который используется для определения точного типа объекта во время выполнения программы.
* **Диспетчеризация примитивов.** Для примитивов (аналогов методов в Java или C++) может применяться динамическая диспетчеризация. Это означает, что если у вас есть тип, производный от базового типа, и в нём переопределён примитив, то при вызове этого примитива будет выполнена версия, соответствующая **фактическому типу объекта** в момент выполнения, а не типу переменной.
* **Совместимость типов.** Введены специальные правила, которые позволяют теговому типу, производному от базового, быть **статически совместимым** с этим базовым типом.

# Надклассовые типы

"Данный объект относится к этому теговому типу или любому его потомку".

`O3 : My_Class'Class := O2;`

**Обратите внимание:**
Поскольку объект над классового типа может иметь размер, соответствующий любому из его потомков, **его размер заранее неизвестен**.
Из этого следуют важные ограничения:

* **Такой тип является неопределённым**, со всеми вытекающими последствиями.
* **Он не может использоваться как поле (компонента) записи.**
* **Объект над классового типа должен быть инициализирован немедленно.**
  Вы не можете ограничить (или отложить) создание объекта этого типа каким-либо иным способом, кроме как через **непосредственную инициализацию**.

# Точечная нотация

Если диспетчеризирующий параметр примитива является **первым параметром** (как в наших примерах), то вы можете вызвать этот примитив, используя **точечную нотацию**.
